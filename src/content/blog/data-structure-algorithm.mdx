---
title: Data Structure
slug: data-structure-algorithm
description: 'DSA'
date: 2024-11-17
thumbnail: 'albertmanuel.com/blog/mfdsvl14c2u7d2wp649y'
published: false
featured: false
---

## Data Structure and Algorithm


#### Data Structure

Data struktur adalah cara data tertentu disimpan di memori dan diambil untuk digunakan nanti.

Data yang disimpan dapat bertype apapun. **Data primitif** seperti string, integer atau float, boolean. **Data non-primitif** seperti Array, Object, linked lists, stacks, queues.

#### Algorithm

Algoritma adalah suatu cara untuk menyelesaikan permasalahan yang telah diketahui. 

Saat ini sudah ada banyak tipe algoritma. Algoritma yang populer dan sering digunakan adalah sorting and searching.

## What is Big O?

Big O (O stands for Omicron) adalah perhitungan matematis untuk menghitung kompleksitas suatu program dalam menyelesaikan tugasnya. Kompleksitas dibagi menjadi 2 yaitu time complexity (kompleksitas berdasarkan waktu) dan space complexity (kompleksitas berdasarkan memori yang digunakan). 

Terdapat 3 notasi matematis yang umum ditemui ketika berbicara tentang kompleksitas:

Î© = Omega â†’ Best Case â†’ Tingkat paling rendah dalam perhitungan worst-case complexity

Î˜ = Theta â†’ Average Case â†’ Tingkat menengah dalam perhitungan worst-case complexity

O = Omicron â†’ Worst Case â†’ Tingkatan paling tinggi dalam perhitungan worst-case complexity 

Reference: [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)

Contoh:

```jsx {1-2}
const arr = [1,2,3,4,5,6,7]

// Angka 1 pada index ke-0 adalah Omega
// Angka 4 pada index ke-3 adalah Theta
// Angka 7 pada index ke-6 adalah Omicron
```

Pada contoh di atas, index ke-0 diasumsikan sebagai **Omega** *(Î©)* atau *Best Case* karena jumlah iterasi yang dilakukan untuk mendapatkan value pada index tersebut paling sedikit (*least*) jika dibandingkan dengan jumlah iterasi yang dilakukan untuk mendapatkan value di index lainnya. Dalam hal ini untuk mendapatkan value 4 dan 7. Sedangkan index ke-3 diasumsikan sebagai **Theta** (Î˜) atau *Average Case* karena jumlah iterasi yang dilakukan untuk mendapatkan value pada index ke-3 berada diantara Omega dan Omicron, yang artinya jumlah iterasi Theta lebih banyak dari yang dilakukan oleh Omega namun jumlah iterasinya masih lebih sedikit daripada Omicron. Terakhir, index ke-6 diasumsikan sebagai **Omicron** (Big O) atau *Worst Case* karena jumlah iterasi yang dilakukan untuk mendapatkan value pada index ke-6 adalah yang terbanyak jika dibandingkan dengan semua index sebelumnya.

<aside>
ğŸ’¡ Jadi, ketika berbicara tentang Big O maka kita berbicara tentang perhitungan kompleksitas pada kasus terburuk (Worst Case)

</aside>

### Big O Notations

- O(n) â†’ hasil perhitungan dari O(n) akan selalu sama *(proportional)* dengan nilai *n-*nya*.*
    
    Misalkan *n* input adalah 5, maka penulisan notasinya adalah O(5) yang berarti jumlah operasi/proses yang dilakukan adalah sebanyak 5 operasi/proses. Sebagai contoh dapat dilihat pada code berikut:
    
    ```jsx
    const logItems = (n) => {
    	for(let i = 0; i < n; i++) {
    		console.log(i)
    	} 
    }
    
    logItems(5)
    
    // Result
    0
    1
    2
    3
    4
    ```
    
    Pada code di atas, function logItems melakukan loop/iterasi sebanyak *n,* dalam kasus ini *n* adalah 5. Jika function tersebut dijalankan, maka *result* yang didapatkan adalah 0,1,2,3,4 yang mana jumlah angkanya ada 5. Maka dari itu dapat dikatakan bahwa function di atas menerapkan O(n) complexity.
    
    O (n^2) or O (n^m) â†’ Complexity yang dihasilkan dari loop within loop atau nested loop (perulangan bersarang). 
    
    **m** adalah banyaknya proses yang dilakukan secara bersarang (nested)
    
    ```jsx
    function logItems(n) {
    	for(let i = 0; i < n; i++) { // --> m = 1
    		for(let j = 0; j < n; j++) { // --> m = 2
    			console.log(i, j)
    		}
    	}
    }
    
    logItems(2)
    
    // result
    i j
    0 0
    0 1
    0 2
    1 0
    1 1
    1 2
    2 0
    2 1
    2 2
    ```
    
    O(1) â†’ Complexity dari proses yang terjadi secara linear, tidak peduli seberapa besar nilai **n** yang diolah. O(1) adalah notasi yang paling efisien dibandingkan dengan notasi Big O lainnya, hal ini dikarenakan operasi yang dilakukan tidak berubah walaupun nilai **n** bernilai berapapun dan nilai **n** berubah-ubah
    
    ```jsx
    function addItems(n) {
    	return n + n + n
    }
    ```
    
    O(log n) â†’ Complexity dari teknik devide and conquer. Devide and conquer adalah teknik memilah part mana yang dijadikan fokus dan mana yang sebaiknya dihiraukan (tidak dilakukan), tujuannya adalah untuk memperkecil banyaknya proses yang dilakukan ketika mencari suatu value di dalam struktur data seperti Array. 
    
    ```jsx
    const array = [1,2,3,4,5,6,7,8]
    
    n -> banyaknya value di dalam array
    m -> proses ke-m
    
    Misalkan ingin mendapatkan value 2, maka teknik devide and conquer akan berjalan seperti berikut:
    
    m 1 -> array dibagi 2 bagian left and right
    left       right
    [1,2,3,4] [5,6,7,8]
    Apakah value 2 ada di left atau right? Karena 2 ada di left, maka kita abaikan yang right
    
    m 2 -> [1,2,3,4]
    array dibagi menjadi 2 bagian lagi, left and right
    left  right
    [1,2] [3,4]
    apakah value 2 ada di left atau right? Karena 2 ada di left, maka kita abaikan lagi yang right
    
    m 3 -> [1,2] 
    array dibagi menjadi 2 bagian lagi, left and right
    left right
    [1]  [2]
    Apakah value 2 ada di left atau right? Karena 2 ada di right, maka kita abaikan yang left 
    Akhirnya, value 2 ditemukan pada pada proses ke-3 atau m = 3.
    
    Maka bisa dikatakan:
    n => 8 
    m => 3
    
    Maka banyaknya proses yang dilakukan untuk mendapatkan value 2 
    dari array tersebut adalah sebanyak 3 proses. Hal ini dibuktikan dengan
    rumus logaritma yaitu:
    log2 n = m
    log2(8) = 3
    ```
    

## Data Structures

### Linked Lists

![comparison between linked lists and arrays on certain process]

comparison between linked lists and arrays on certain process

Under the hood, linkedin list would be like this:

```jsx
head: {
	{
		value: 10, 
		next: {
			value: 22,
			next: {
				value: 40,
tail:	  next: {
					value: 60,
					next: null
				}
			}
		}
	}
}

```